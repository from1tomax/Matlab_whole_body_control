function out = vehicle_calc(m, T_V_I, Inertia, pd_I, omega_I, wr, varargin) 
% This function calculates the matricies for the dynamic equation of a
% non-holonomic vehicle. The vehicle is composed of different objects. The 
% inertia parameters of the objects can be specified, as well as own
% velocities e.g. rotations for the wheels. With these informations the
% mass matrix M, the Coriolis vector C, the gravity vector G, the
% non-holonomic constraint matrix A and the nullspace of it, the S matrix
% are calculated.
%
% Inputs: 
% (no = number of objects)
% 
% m = array with object masses; size [1 x no]
% T_V_I = 3D-array with transformation matricies stacked in third
%         dimension, which specifiy the location of the objects Center of
%         mass relative to the vehicle frame and the orientation of the
%         object frame. The orientation is needed for fitting the inertias;
%         size [4 x 4 x no]
% Inertia = Inertias of the objects; rotation is assumed to be the same as 
%   specified in T_V_I! Input is either in third dimension concated inertia 
%   matricies; so size=[3 x 3 x no] or a matrix with 
%   [Ixx Iyy Izz Ixy Ixz Iyz]' as columns and size [6 x no].
% pd_I = own translatory velocity of the objects relative to the vehicle 
%   frame. So e.g. the fork of a fork lift has a translatory velocity while
%   moving up and down. Size = [3 x no]
% omega_I = own rotatory velocity of the objects relative to the vehicle 
%   frame. So e.g. the wheels of the car spin around their own axis, either 
%   for driving or for steering. Size = [3 x no]. Driving spin velocity is
%   named thetadX, were X labels the wheel, this cannot be changed.
% wr = wheelradius, if scalar all wheels are assumed to have same size, but
%   the number of wheels has to be specified with nw option in this case.
%   If wr is a array, each entry is assumed to be for one wheel, nw option
%   is not neccessary.
%
% varargin in options:
% use in function call like: ..., 'option name', value, ...
% debug = Set to true if you want some not understandable debug output
%   (default is false) and the parallel pool stays alive!
% quiet = Set to true if you don't want to see all the printed information.
%   default is false; Errors and Warnings are always displayed; debug
%   forces true;
% (desired_digits = DEPRECIATED specifiy the desired digits for the calculations;
%   default is 4:)
des_digits_default = 4;
% optimize = default is 3; higher values include what lower values do: 
%   0 = no optimization all elements are calculated
%   1 = only the lower left corner of the mass matrix is calculated, the 
%       upper half is generated by using the symmetry of mass matricies
%   2 = start from 2. row, since M(1,1) = M(2,2)
%   3 = start from 3. row, since translatory mass is sum of all objects
% save_fct = char array determining which matrix to save as matlab 
%   function, e.g. 'M C'. Default is empty, but you can choose from 
%   'M C G J A S Sd Sq' = 'all'.
% (save_split = DEPRECIATED char array determining which matrix to save in elementwise
%   matlab functions, e.g. 'M C'. Default is empty, but you can again 
%   choose from 'M C G J A S Sd Sq' = 'all'. Matrices
%   specified in this array override save_fct. So you can set save_fct =
%   'all' and save_split = 'C', to save all matricies as functions, except
%   C is saved elementwise. The elementwise matlab functions are saved in a
%   folder named 'filename_prefix MATRIX_NAME'.)
% path = char array used as path to the location where to write the output.
% filename_prefix = char array used as prefix for filenames while saving  
%   output, e.g. 'get_' results in filenames 'get_M.m'.
% fileopt_act = bool, default is false. Determine if save to .m file should
%   optimize the function. Takes longer, but can also help to generate C
%   code, there its always active.
% filec_act = bool, default is false. Output C code function additionally
%   to mat file if true. fileopt_act has no influence.
% file_pct_act = use Parallel Computing Toolbox (PCT) for output code 
%   generation. This uses the PC better with big robots, if code generation
%   is active. This is inheritet from another function and not really needed here.
%   0 = no PCT used (default)
%   1 = always use PCT (if available)
% simplify_act = use simplify for the output; default is 1; since the
%       systems are easy to solve here
%   0 = no simplify used
%   1 = always use simplify
%   (-1 = Use PCT for M, forces level 1; DEPRECIATED)
% nw = number of wheels option; specify a positive integer, if wr is not an
%   array.
% static_act = calculations for kinetic energy are done in static world
%   frame if true; default is false, so kinetic energy is calculated in
%   moving frame. Actually this should make no difference, but both was
%   already programmed.
% q_extern = Specify additional variables for the q vector of the vehicle.
%   The standard q is [x y phi thetaX], so first the location and
%   orientation on the xy-plane and then the current turning angles of the
%   wheels. 
% qd_extern = Derivative of q_extern. Must have same length
% cut_A_act = Neglect equal rows in A, if true, which is default
% scale_S_act = Scale S matrix so that S(3,1) == 1; only used if S has two
%   columns and S(3,1)~=0; throws warning if S has not the shape
%   [x 0]
%   [1 0]
%   [0 1] 
%   Where x is a vector of arbitary length
% C_mat = bool; set false if you want the C vector. default is
%       true, which returns the C matrix
%
% Output:
%
% Output is a struct with the matricies specified in the following:
% M is always included
C_calc_act = true;
G_calc_act = true;
J_calc_act = true;
A_calc_act = false;
S_calc_act = false;  %only if A_calc_act
Sd_calc_act = false; %only if S_calc_act
Sq_calc_act = false; %only if S_calc_act

% Activate this one to get var names with trailing v
vehicle_act = true;
%
%
% Future work:
%
% - other input method for matrix calc choices
% - allow other wheel spin names (theta(d)X)
% - allow other vehicle frame system (not z upwards) ??
%   -> calc internally with 3d and cut finally; -not effcient/possible
%   -> orientation problems with three angles!
%
% Internal used frame naming scheme:
%
% T_1_2 = TF from 1 to 2
% _W = Worldframe
% _V = Vehicle frame (= CoM vehicle, actually not neccessarily, I think)
% _I = Ojects frames
% _S = Start frame for energy calculations; specified in comments
% gen coo = generalized coordinates

%% IO Check and init
%Start stopwatch
tic;

% first check Matlab version due to dynamic syms
if verLessThan('matlab','9.7')
    error('At least Matlab 2019B is required.')
end

% Check basic inputs
idx = 1;
validateattributes(m,{'numeric','sym'},{'vector','nonnan','finite','real'},'','Mass m',idx);
idx = idx+1;
if size(m,1)>size(m,2) %lay vector 
    m = m.';
end
no = size(m,2); %Number of all objects
if isa(m,'numeric') %force symbolic
    validateattributes(m,{'numeric'},{'nonnegative'},'','Mass m',idx);
    m_i = sym(m);
else
    assumeAlso(m,'real') 
    assumeAlso(m >= 0) 
    m_i = m; % better understandable code later
end
%output vars
if isa(m,'numeric') 
    m_var = [];
else
    m_var = symvar(m);
    if numel(m_var)==no
        m_var = m;
    end
end

validateattributes(T_V_I,{'numeric','sym'},{'3d','nonnan','finite','real','numel', 16*no},'','TFs to objects T_V_I',idx);
idx = idx+1;
if ~all(size(T_V_I) == [4 4 no])
    error('wrong size of T_V_I 3D-array! Expected size 4 x 4 x #objects');
end
%output vars
if isa(T_V_I,'numeric') 
    T_V_I_var = [];
else
    T_V_I_var = symvar(T_V_I);
    if numel(T_V_I_var) == 12*no %Rot matrix and Pos vector
        T_V_I_var = T_V_I(r,:,:);
    end
end
if isa(T_V_I,'numeric') %force symbolic
    T_V_I = sym(T_V_I);
else
    assumeAlso(T_V_I,'real') 
end

validateattributes(Inertia,{'numeric','sym'},{'3d','nonnan','finite','real'},'','Inertia matrix (Inertia)',idx);
idx = idx+1;
% determine input way of inertia if not estimate
if size(Inertia,3) > 1 || (size(Inertia,1)==3 && size(Inertia,2)==3) % 3d input or just one joint
    inertia_in = 3;
    if size(Inertia,1)~=3 || size(Inertia,2)~=3 || size(Inertia,3)~=no
        error('Size of inertia not correct! 3D matrix input: 3x3 inertia matricies stacked in third dimension. Third dimension has number of links size.');
    else
        if isa(Inertia,'numeric') %force symbolic
            Inertia_i_I = sym(Inertia);
        else
            Inertia_i_I = Inertia;
        end
    end
else % 2d input
    inertia_in = 2;
    if size(Inertia,1)~=6 && size(Inertia,2)~=6 % Check for one side 6 elements 
        error('Size of inertia not correct! Matrix with [Ixx Iyy Izz Ixy Ixz Iyz] as columns and size [6 x #objects].');
    end
    if size(Inertia,1)~=6 %ensure 6xno 
        Inertia = Inertia.';
    end
    if size(Inertia,2)~=no %check no length
        error('Size of inertia not correct! Matrix with [Ixx Iyy Izz Ixy Ixz Iyz] as columns and size [6 x #objects].');
    end
    Inertia_i_I = sym(zeros(3,3,no));
    if isa(Inertia,'numeric') %force symbolic
        Inertia_int = sym(Inertia);
    else
        Inertia_int = Inertia;
    end
    for jdx=1:no
        Inertia_i_I(1,2,jdx) = Inertia_int(4,jdx); % fill upper left corner
        Inertia_i_I(1,3,jdx) = Inertia_int(5,jdx);
        Inertia_i_I(2,3,jdx) = Inertia_int(6,jdx);
        Inertia_i_I(:,:,jdx) = Inertia_i_I(:,:,jdx) + Inertia_i_I(:,:,jdx).'; % flip to lower right corner
        Inertia_i_I(:,:,jdx) = Inertia_i_I(:,:,jdx) + diag(Inertia_int(1:3,jdx)); % Add diagonal elements
    end
    clear Inertia_int
end
%output vars
if isa(Inertia,'numeric') %Inertia_est_act case at the output generation
    Inertia_var = [];
else
    Inertia_var = symvar(Inertia);
    if (inertia_in == 2 && numel(Inertia_var) == (6*no)) || ...
       (inertia_in == 3 && numel(Inertia_var) == (9*no))
        Inertia_var = Inertia;
    end
end
clear inertia_in

validateattributes(pd_I,{'numeric','sym'},{'2d','nonnan','finite','real','numel', 3*no},'','Translatory velocity (pd_I)',idx);
idx = idx+1;
if size(pd_I,1)~=3 && size(pd_I,2)~=3 % Check for one side 3 elements 
    error('pd_I must be a matrix with size either 3 x no or no x 3.');
end
if size(pd_I,1)~=3 %ensure 3xno 
    pd_I = pd_I.';
end
if size(pd_I,2)~=no %check no length
    error('pd_I must be a matrix with size either 3 x no or no x 3.');
end
%output vars
if isa(pd_I,'numeric') %CoM_est_act case at the output generation
    pd_I_var = [];
else
    pd_I_var = symvar(pd_I);
    if numel(pd_I_var) == (3*no)
        pd_I_var = pd_I;
    end
end
if isa(pd_I,'numeric') %force symbolic
    pd_i_I = sym(pd_I);
else
    pd_i_I = pd_I;
    assumeAlso(pd_i_I,'real') 
end

validateattributes(omega_I,{'numeric','sym'},{'2d','nonnan','finite','real','numel', 3*no},'','Rotational velocity (omega_I)',idx);
idx = idx+1;
if size(omega_I,1)~=3 && size(omega_I,2)~=3 % Check for one side 3 elements 
    error('omega_I must be a matrix with size either 3 x no or no x 3.');
end
if size(omega_I,1)~=3 %ensure 3xno 
    omega_I = omega_I.';
end
if size(omega_I,2)~=no %check no length
    error('omega_I must be a matrix with size either 3 x no or no x 3.');
end
%output vars
if isa(omega_I,'numeric') %CoM_est_act case at the output generation
    omega_I_var = [];
else
    omega_I_var = symvar(omega_I);
    if numel(omega_I_var) == (3*no)
        omega_I_var = omega_I;
    end
end
if isa(omega_I,'numeric') %force symbolic
    omega_i_I = sym(omega_I);
else
    omega_i_I = omega_I;
    assumeAlso(omega_i_I,'real') 
end

validateattributes(wr,{'numeric','sym'},{'vector','nonnan','finite','real'},'','Wheel radius wr',idx);
idx = idx+1;
%output vars
if isa(wr,'numeric') 
    wr_var = [];
else
    wr_var = symvar(wr);
    if numel(wr_var)==no
        wr_var = wr;
    end
end
if isa(wr,'numeric') %force symbolic
    validateattributes(wr,{'numeric'},{'nonnegative'},'','Mass m',idx);
    wr = sym(wr);
else
    assumeAlso(wr,'real') 
    assumeAlso(wr >= 0) 
end

% Check input
narginchk(6,42);
% define parser and add arguments
iparser = inputParser;
addOptional(iparser,'debug',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'quiet',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'optimize',3,@(x)validateattributes(x,{'numeric'},{'scalar','integer','>=', 0,'<=', 3}));
addOptional(iparser,'file_pct_act',0,@(x)validateattributes(x,{'numeric'},{'scalar','integer','>=', 0,'<=', 1}));
addOptional(iparser,'simplify_act',1,@(x)validateattributes(x,{'numeric'},{'scalar','integer','>=', -1,'<=', 1}));
%5
addOptional(iparser,'desired_digits',des_digits_default,@(x)validateattributes(x,{'numeric'},{'scalar','integer','nonnan','finite','positive'}));
addOptional(iparser,'q_extern',[],@(x)validateattributes(x,{'sym'},{'vector'}));
addOptional(iparser,'qd_extern',[],@(x)validateattributes(x,{'sym'},{'vector'}));
addOptional(iparser,'static_act',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'nw',0,@(x)validateattributes(x,{'numeric'},{'scalar','integer','nonnan','finite','positive'}));
%10
addOptional(iparser,'cut_A_act',true,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'scale_S_act',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'C_mat',true,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
addOptional(iparser,'filename_prefix','',@(x)validateattributes(x,{'string','char'},{'scalartext'}));
addOptional(iparser,'fileopt_act',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));
%15
addOptional(iparser,'path','',@(x)validateattributes(x,{'string','char'},{'scalartext'}));
addOptional(iparser,'save_fct','',@(x)validateattributes(x,{'string','char'},{'scalartext'}));
%addOptional(iparser,'save_split','',@(x)validateattributes(x,{'string','char'},{'scalartext'}));
addOptional(iparser,'filec_act',false,@(x)validateattributes(x,{'logical'},{'scalar','binary'}));

% do parsing and store results
parse(iparser,varargin{:});
debug = iparser.Results.debug;
quiet = iparser.Results.quiet;
optimize = iparser.Results.optimize;
file_pct_act = iparser.Results.file_pct_act;
simplify_act = iparser.Results.simplify_act;
des_digit = iparser.Results.desired_digits;
q_extern = iparser.Results.q_extern;
qd_extern = iparser.Results.qd_extern;
static_act = iparser.Results.static_act; %static or moving frames; because I did it already
nw = iparser.Results.nw;
scale_S_act = iparser.Results.scale_S_act;
cut_A_act = iparser.Results.cut_A_act;
C_mat_act = iparser.Results.C_mat;
filename_prefix = iparser.Results.filename_prefix;
fileopt_act = iparser.Results.fileopt_act;
path = iparser.Results.path;
save_fct = iparser.Results.save_fct;
% save_split = iparser.Results.save_split;
save_split = '';
filec_act = iparser.Results.filec_act;

% if debug it cannot be quiet
if debug
    quiet = false;
end

% A bit of information for the user
if ~quiet
    disp('Initialize vehicle dynamics calculation function. Start with IO-check ...');
end

% some basic vars
digits(des_digit); %digits for vpa()
r1 = 1:3; %rotation cutter; TF(r1,r1)...
nv = 3; %number of vehicle dof
nul = sym(0); % a symbolic zero for some inits

%number of wheels
if isscalar(wr)
    if nw==0
        error('Please determine number of wheels with nw option or specify vector in wr!');
    end
    wr = sym(ones(1,nw))*wr;
else
    if size(wr,1)>size(wr,2)
        wr = wr.';
    end
    nw = size(wr,2);
    if ~all(size(wr) == [1 nw])
        error('wrong size of wheelradius vector wr! Expected length is #wheels (or scalar)');
    end
end

% q extern
if ~isempty(q_extern) && ~isempty(qd_extern)
    if size(q_extern,1)>size(q_extern,2)
        q_extern = q_extern.';
    end
    if size(qd_extern,1)>size(qd_extern,2)
        qd_extern = qd_extern.';
    end
    nqe = size(q_extern,2); 
    if size(qd_extern,2) ~= nqe
        error('q_extern and qd_extern must have equal length!');
    end
    if ~all(size(q_extern) == [1 nqe])
        error('wrong size of q_extern vector!');
    end
    if ~all(size(qd_extern) == [1 nqe])
        error('wrong size of qd_extern vector!');
    end
elseif isempty(q_extern) && isempty(qd_extern)
    nqe = 0;
    qd_extern = [];
    q_extern = [];
else
    warning('Specify either both of q_extern and qd_extern, or none of them! (Ignoring now)');
    nqe = 0;
    qd_extern = [];
    q_extern = [];
end

%pct
if file_pct_act>0 && ~hasParallelToolbox()
    warning('No Parallel Computing Toolbox found. Cannot use.');
    file_pct_act=0;
end
if simplify_act==-1 && ~hasParallelToolbox()
    warning('No Parallel Computing Toolbox found. Cannot use.');
    simplify_act=1;
end

% Check path
path = fullfile(path);
% Append \ or / to path 
if ~isempty(path) && ~strcmp(path(end),filesep)
    path = [path filesep];
end

% What to save as function?
if contains(save_fct,'all')
    save_fct = [save_fct ' M C G J A S Sd Sq '];
end
save_fct = [save_fct ' ']; % append empty space for checks


%% init
% A bit of information for the user
if ~quiet
    disp('Continue with initialize other variables ...');
end

%number of qs
nq = nv + nw + nqe;

M_end = nq;
% optimize by leaving out some parts and using knowledge about update matrix
if optimize==0
    M_start = 1;
elseif optimize==1
    M_start = 1;
elseif optimize==2
    M_start = 2;
elseif optimize>=3
    M_start = 3;
end

% syms variables
syms x y phi
qv = [x y phi];
syms xd yd phid
qdv = [xd yd phid];
syms theta [1 nw]
syms thetad [1 nw]

% build vector with all gen coo velocities for derivatives
xqdin = [qdv thetad qd_extern];
xqin = [qv theta q_extern];

% location of vehicle in world 3D
T_W_V = sym([ ...
    cos(phi), -sin(phi), 0, x
    sin(phi),  cos(phi), 0, y
    0,          0,       1, 0
    0,          0,       0, 1 ]);

% velocities of vehicle
omega_v_W = [nul;nul;phid];
pd_v_W = [xd;yd;nul];

% calc transformation from World to objects
T_W_I = sym(zeros(size(T_V_I)));
for idx=1:no
    % T_W_I
    T_W_I(:,:,idx) = T_W_V * T_V_I(:,:,idx);
end

%% Calc kinetic energy
% A bit of information for the user
if ~quiet
    disp('Calculate kinetic energy K of objects ...');
end
K_i = sym(zeros(1,no));
pd_iv_I = sym(zeros(size(pd_i_I)));
if static_act
    % Calculate kinetic energy (in W-frame, static frame!)
    for idx=1:no
        % Inertia turn
        Inertia_W = T_W_I(r1,r1,idx) * Inertia_i_I(:,:,idx) * T_W_I(r1,r1,idx).';
        % omega_i_W of its own
        omega_iv_W = T_W_I(r1,r1,idx) * omega_i_I(:,idx);
        % add omega of vehicle
        omega_iv_W = omega_iv_W + omega_v_W;

        % translatory velocity of object is: own plus velocity of vehicle ...
        pd_iv_W = T_W_I(r1,r1) * pd_i_I(:,idx) + pd_v_W;
        % radius for trans velocity update = rotate to W frame
        radius_W = T_W_V(r1,r1) * T_V_I(r1,4,idx); 
        % ... plus omega update.
        pd_iv_W = pd_iv_W + Sk(omega_v_W) * radius_W; 

        % Energy of object
        K_i(idx) = sym(1/2)*( m_i(idx) * (pd_iv_W.') * pd_iv_W ...
                 + (omega_iv_W.') * Inertia_W * omega_iv_W );

        % compute velocity for A calc
        pd_iv_I(:,idx) = (T_W_I(r1,r1,idx).') * pd_iv_W;
    end
    clear Inertia_W omega_iv_W pd_iv_W radius_W

else
    % Calculate kinetic energy (In I-Frame; moving frames!)
    for idx=1:no    
        % add omega of vehicle to own omega
        omega_iv_I = omega_i_I(:,idx) + (T_W_I(r1,r1,idx).') * omega_v_W;

        % translatory velocity of object is: own plus velocity of vehicle ...
        pd_iv_I(:,idx) = pd_i_I(:,idx) + (T_W_I(r1,r1,idx).') * pd_v_W;
        % radius for trans velocity update and omega of V in V
        radius_V = T_V_I(r1,4,idx); 
        omega_v_V = (T_W_V(r1,r1).') * omega_v_W; 
        % ... plus omega update, from V to I.
        pd_iv_I(:,idx) = pd_iv_I(:,idx) + (T_V_I(r1,r1,idx).') * (Sk(omega_v_V) * radius_V); 

        % Energy of object
        K_i(idx) = sym(1/2)*( m_i(idx) * (pd_iv_I(:,idx).') * pd_iv_I(:,idx) ...
                 + (omega_iv_I.') * Inertia_i_I(:,:,idx) * omega_iv_I );
    end
    clear omega_iv_I radius_V omega_v_V
end

% sum up energies
K = sum(K_i,2);

%% Calculating M elementwise
% Differantiate K twice to velocities ==> Mass Matrix
if ~quiet
    % pre face for status
    disp('Calculate mass matrix M with differentiating energy K twice ...');
    print_pre_calc(M_end,M_start)
end
% M is mass matrix; maybe only a part of it
M = sym(zeros(nq,M_end));
for idx = M_start:nq
    Min = sym(zeros(nq,M_end));
    Min(idx,:) = M_calc_from_K(idx,M_end,quiet,optimize,K,xqdin);
    M = M + Min;
end

%% post processing    
if ~quiet
    disp('Start post processing for M ...');
end

% Do simplify maybe
if simplify_act==-1
    simplify_act = 1;%for rest
    if ~quiet
        % pre face for status
        disp('Simplify with Parallel computing...');
    end
    if isempty(gcp('nocreate'))
        parpool('local');
        close_pool = true;
    else
        close_pool = false;
    end
    M2 = sym(zeros(nq,M_end));
    parfor jdx=M_start:nq
        % Min M2 ... due to parfor
        Min_row = sym(zeros(1,M_end));

        % optimize: calculate only lower left corner and later flip this up,
        % because of mass matrix symmetry
        if optimize>0
            line_end = jdx;
        else
            line_end = M_end;
        end

        for hdx=1:line_end
            Min_row(1,hdx) = simplify(M(jdx,hdx));
            if ~quiet
                disp(['Finished: ' int2str(jdx) ' x ' int2str(hdx)]);
            end
        end
        Min = sym(zeros(nq,M_end));
        Min(jdx,:) = Min_row;
        M2 = M2 + Min;
    end
    M = M2;
    if close_pool && ~debug
        delete(gcp('nocreate'));
    end
    clear M2 Min Min_row close_pool

elseif simplify_act>=1
    if ~quiet
        % pre face for status
        disp('Simplify without Parallel computing...');
        print_pre_calc(M_end,M_start)
    end
    for jdx=M_start:nq
        if ~quiet
            fprintf('%i. Row: ', jdx);
        end
        % optimize: calculate only lower left corner and later flip this up,
        % because of mass matrix symmetry
        if optimize>0
            line_end = jdx;
        else
            line_end = M_end;
        end

        for hdx=1:line_end
            if ~quiet
                fprintf('o');
            end
            M(jdx,hdx) = simplify(M(jdx,hdx));
            if ~quiet
                fprintf('\b');
                fprintf('v ');
            end
        end
        % Print line break if finished
        if ~quiet
            fprintf('\n');
        end
    end
end

% De-optimize M
if optimize>=3
    M(2,1) = sym(zeros(1,1)); % second row first element is always zero.
    M(2,2) = sum(m_i,2); % translatory mass update is sum of arm masses ...
end
if optimize>=2
    M(1,1) = M(2,2);     % ... and actually the same for x and y
end
if optimize>=1 % if optimize 1: flip up the calculated lower left corner
    M = tril(M,0) + tril(M,-1).';
end

% output 
out.M = M;

%% C_calc
if C_calc_act
    if ~quiet
        disp('Calculate Coriolis term C with Christoffel symbols ...');
    end
    C = C_calc(M,xqin,xqdin,C_mat_act);
    if simplify_act>=1
        if ~quiet
            disp('Simplify C  ...');
        end
        C = simplify(C);
    end
    % output 
    out.C = C;
end

%% G_calc
if G_calc_act
    if ~quiet
        disp('Calculate Gravity vector G ...');
    end
    G = G_calc(xqin,m_i,T_W_I);
    if simplify_act>=1
        if ~quiet
            disp('Simplify G  ...');
        end
        G = simplify(G);
    end
    % output 
    out.G = G;
end

%% J_calc
if J_calc_act
    if ~quiet
        disp('Set vehicle Jacobian J...');
    end
    J = sym(...
        [1 0 0
         0 1 0
         0 0 0
         0 0 0
         0 0 0
         0 0 1]);
    if (nw + nqe)>0
        J = [J sym(zeros(6,nw + nqe))];
    end
    % output 
    out.J = J;
end

%% A_calc
if A_calc_act
    if ~quiet
        disp('Calculate constraint matrix A with differentiating velocities ...');
    end
    A = A_calc(pd_iv_I(:,1:nw),xqdin,wr,thetad,cut_A_act);
    if simplify_act>=1
        if ~quiet
            disp('Simplify A  ...');
        end
        A = simplify(A);
    end
    % output 
    out.A = A;
    
    if S_calc_act
        if ~quiet
            disp('Calculate S matrix which is nullspace of A ...');
        end
        S = null(A);
        if scale_S_act && size(S,2) == 2 && ~isequal(S(3,1),sym(0))
            if ~isequal(S(:,2),sym([zeros(size(S,1)-1,1);1])) || ...
               ~isequal(S(end-1:end,1),sym([1;0]))
                warning('S is not expected shape')
            end
            S = [S(:,1)./S(3,1), S(:,2)];
        end
        if simplify_act>=1
            if ~quiet
                disp('Simplify S  ...');
            end
            S = simplify(S);
        end
        % output 
        out.S = S;
        
        if Sd_calc_act
            % S dot
            if ~quiet
                disp('Calculate Sd matrix which is diff(S,t) ...');
            end
            Sd = diff_t(S,xqin,xqdin);
            if simplify_act>=1
                if ~quiet
                    disp('Simplify Sd  ...');
                end
                Sd = simplify(Sd);
            end
            % output 
            out.Sd = Sd;
        end
        if Sq_calc_act
            % diff(S,q)
            if ~quiet
                disp('Calculate Sq matrices which is diff(S,q) ...');
            end
            Sq = sym(zeros(size(S,1),size(S,1),size(S,2)));
            for i=1:size(S,2)
                for j=1:size(S,1)
                    Sq(:,j,i) = diff(S(:,i),xqin(j));
                end
            end
            if simplify_act>=1
                if ~quiet
                    disp('Simplify Sq  ...');
                end
                Sq = simplify(Sq);
            end
            % output 
            out.Sq = Sq;
        end
    end
end
%% Output generation
% A bit of information for the user
if ~quiet
    disp('All Calculations done. Generating output ...');
end

% variables of output
add_vars_Dyn = {}; %Additional vars from Dynamics
if ~isempty(m_var)
    add_vars_Dyn = cat(2,add_vars_Dyn,{'m';m_var});
end
T_V_I_var = setdiff(T_V_I_var,xqin,'stable');
if ~isempty(T_V_I_var)
    add_vars_Dyn = cat(2,add_vars_Dyn,{'T_V_I';T_V_I_var});
end
if ~isempty(Inertia_var)
    add_vars_Dyn = cat(2,add_vars_Dyn,{'Inertia';Inertia_var});
end

add_vars_Kin = {}; %Additional vars from Kinematics
pd_I_var_static = setdiff(pd_I_var,[xqin xqdin T_V_I_var],'stable');
if ~isempty(pd_I_var_static)
    add_vars_Kin = cat(2,add_vars_Kin,{'pd_I';pd_I_var_static});
end
omega_I_var_static = setdiff(omega_I_var,[xqin xqdin T_V_I_var],'stable');
if ~isempty(omega_I_var_static)
    add_vars_Kin = cat(2,add_vars_Kin,{'omega_I';omega_I_var_static});
end

jdx = 1;
%M
%if M_calc_act
    if vehicle_act
        vars = {'qv'; xqin};
    else
        vars = {'q'; xqin};
    end
    if ~isempty(add_vars_Dyn)
        vars = cat(2,vars,add_vars_Dyn);
    end
    if ~isempty(add_vars_Kin)
        vars = cat(2,vars,add_vars_Kin);
    end
    save_cell{jdx} = save_mat_check(out.M,'M',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    if vehicle_act && ~isempty(save_cell{jdx})
        save_cell{jdx}.mat_name = [save_cell{jdx}.mat_name 'v'];
    end
    jdx = jdx + 1;
    clear vars
% end

%C
if C_calc_act
    if vehicle_act
        vars = {'qv' 'qdv'; xqin xqdin};
    else
        vars = {'q' 'qd'; xqin xqdin};
    end
    if ~isempty(add_vars_Dyn)
        vars = cat(2,vars,add_vars_Dyn);
    end
    if ~isempty(add_vars_Kin)
        vars = cat(2,vars,add_vars_Kin);
    end
    save_cell{jdx} = save_mat_check(out.C,'C',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    if vehicle_act && ~isempty(save_cell{jdx})
        save_cell{jdx}.mat_name = [save_cell{jdx}.mat_name 'v'];
    end
    jdx = jdx + 1;
    clear vars
end

%G
if G_calc_act
    if vehicle_act
        vars = {'qv'; xqin};
    else
        vars = {'q'; xqin};
    end
    if ~isempty(m_var)
        vars = cat(2,vars,{'m';m_var});
    end
    if ~isempty(T_V_I_var)
        vars = cat(2,vars,{'T_V_I';T_V_I_var});
    end
    syms g real
    vars = cat(2,vars,{'g';g});
    save_cell{jdx} = save_mat_check(out.G,'G',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    if vehicle_act && ~isempty(save_cell{jdx})
        save_cell{jdx}.mat_name = [save_cell{jdx}.mat_name 'v'];
    end
    jdx = jdx + 1;
    clear vars
end

%J
if J_calc_act
    vars = {'';sym([])};
    save_cell{jdx} = save_mat_check(out.J,'J',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    if vehicle_act && ~isempty(save_cell{jdx})
        save_cell{jdx}.mat_name = [save_cell{jdx}.mat_name 'v'];
    end
    jdx = jdx + 1;
    clear vars
end

%A
if A_calc_act
    %init vars only for A, all S have the same
    if vehicle_act
        vars = {'qv' 'qdv'; xqin xqdin};
    else
        vars = {'q' 'qd'; xqin xqdin};
    end
    if ~isempty(wr_var)
        vars = cat(2,vars,{'wr';wr_var});
    end
    if ~isempty(T_V_I_var)
        vars = cat(2,vars,{'T_V_I';T_V_I_var});
    end
    if ~isempty(add_vars_Kin)
        vars = cat(2,vars,add_vars_Kin);
    end
    save_cell{jdx} = save_mat_check(out.A,'A',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    jdx = jdx + 1;
end

%S
if S_calc_act
    save_cell{jdx} = save_mat_check(out.S,'S',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    jdx = jdx + 1;
end

%Sd
if Sd_calc_act
    save_cell{jdx} = save_mat_check(out.Sd,'Sd',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
    jdx = jdx + 1;
end

%Sq
if Sq_calc_act
    for i=1:size(S,2)
        save_cell{jdx} = save_mat_check(out.Sq(:,:,i),'Sq',save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act);
        if ~isempty(save_cell{jdx})
            save_cell{jdx}.mat_name = [save_cell{jdx}.mat_name '_' int2str(i)];
        end
        jdx = jdx + 1;
    end
end

% Make functions
save_cell = save_cell(~cellfun('isempty',save_cell));
if ~isempty(save_cell)
    if file_pct_act
        if ~quiet
            disp('Outputing functions with parallel computing...');
        end
        if isempty(gcp('nocreate'))
            parpool('local');
            close_pool = true;
        else
            close_pool = false;
        end
        parfor idx=1:numel(save_cell)
            save_mat(save_cell{idx},quiet)
        end
        if close_pool && ~debug
            delete(gcp('nocreate'));
        end
    else
        if ~quiet
            disp('Outputing functions without parallel computing...');
        end
        for idx=1:numel(save_cell)
            save_mat(save_cell{idx},quiet)
        end
    end
end

% A bit of information for the user
if ~quiet
    disp('Finished without known errors.');
    toc
end

end

%% Helper functions

function M = Sk(v)
M = sym([ 0    -v(3)  v(2)
          v(3)  0    -v(1)
         -v(2)  v(1)  0   ]);
end

function reply = hasParallelToolbox(S)
% Somewhere from the internet but strongly modified;
% and so far not tested on a machine without parallel toolbox; 
% Sorry I have none :-(

try
    % If the function is available, Toolbox is there
    if isempty(gcp('nocreate')) || ~isempty(gcp('nocreate'))
        hasPPT = true;
    end
catch ME
    if ~strcmp(ME.identifier, 'MATLAB:UndefinedFunction')
      rethrow(ME);
    end
    hasPPT = false;
end
usePPT = hasPPT;

% override through input
if nargin > 0
   usePPT = S && hasPPT;
end

reply = usePPT;
end

function Mr = M_calc_from_K(row,M_end,quiet,optimize,K,xqdin)
    % This is the M matrix calculator

    if ~quiet
        fprintf('%i. Row: ', row);
    end
    
    %init one row of mass matrix
    Mr = sym(zeros(1,M_end));
    
    % 1. diff: Every row of mass matrix
    mm = diff(K,xqdin(row));

    % optimize: calculate only lower left corner and later flip this up,
    % because of mass matrix symmetry
    if optimize>0
        line_end = row;
    else
        line_end = M_end;
    end

    for hdx = 1:line_end
        if ~quiet
            fprintf('o');
        end
        % 2. diff: Every column differentiated
        Mr(1,hdx)=diff(mm,xqdin(hdx));
        if ~quiet
            fprintf('\b');
            fprintf('v ');
        end
    end
    if ~quiet
        fprintf('\n');
    end
end

function print_pre_calc(columns,start_row)
    % Prints header for matrix calc
    fprintf('Column: ');
    for idx=1:columns
        fprintf('%i ', idx);
    end
    fprintf('\n');
    for idx=1:start_row-1
        fprintf('%i. Row: optimized\n', idx);
    end
end

function Split_output_mat(mat,mat_name,path,filename_prefix,vars,fileopt_act,quiet,file_pct_act)
    % This outputs a matrix as single mat files in a folder
    
    full_path = [path filename_prefix mat_name filesep];
    % A bit of information for the user
    if ~quiet
        disp(['Save ' mat_name ' in files: ' [full_path filename_prefix mat_name] '_ROW_COL.m']);
    end
    
    %make folder if not exist
    if ~exist(full_path, 'dir')
        mkdir(full_path)
    end
    
    % A bit of information for the user
    if ~quiet && file_pct_act==0
        print_pre_calc(size(mat,2),1)
    end
    for idx = 1:size(mat,1)
        if ~quiet && file_pct_act==0
            fprintf('%i. Row: ', idx);
        end
        for jdx = 1:size(mat,2)
            if ~quiet && file_pct_act==0
                fprintf('o');
            end
            filename = [full_path filename_prefix mat_name '_' int2str(idx) '_' int2str(jdx) '.m'];
            matlabFunction(mat(idx,jdx),'file',filename,'vars',vars(2,:),'Outputs',{mat_name},'Optimize',fileopt_act);
            repair_input(filename,vars);
            if ~quiet && file_pct_act>0
                disp(['Finished: ' filename_prefix mat_name '_' int2str(idx) '_' int2str(jdx) '.m']);
            end
            if ~quiet && file_pct_act==0
                fprintf('\b');
                fprintf('v ');
            end
        end
        if ~quiet && file_pct_act==0
            fprintf('\n');
        end
    end

end

function save_mat(to_save,quiet)
    % This saves a matrix to file(s)

    if to_save.split
        Split_output_mat(to_save.mat,to_save.mat_name,to_save.path,to_save.filename_prefix,to_save.vars,to_save.fileopt_act,quiet,to_save.file_pct_act)
    end
    if ~to_save.split
        %make folder if not exist
        if ~exist(to_save.path, 'dir')
            mkdir(to_save.path)
        end
        filename = [to_save.path to_save.filename_prefix to_save.mat_name '.m'];
        if ~quiet
            disp(['Generating ' filename ' function ...']);
        end
        matlabFunction(to_save.mat,'file',filename,'vars',to_save.vars(2,:),'Outputs',{to_save.mat_name},'Optimize',to_save.fileopt_act);
        repair_input(filename,to_save.vars);
        if ~quiet && to_save.file_pct_act>0
            disp(['Finished ' filename ' function.']);
        end
        if to_save.filec_act
            if ~quiet
                disp(['Generating C++ functionn in codegen' filesep 'lib' filesep to_save.filename_prefix to_save.mat_name filesep ' ...']);
            end
            args = cell(1,size(to_save.vars,2));
            if ~isempty(to_save.vars{2,1})
                for idx=1:size(to_save.vars,2)
                    args{idx} = coder.typeof(ones(size(to_save.vars{2,idx})));
                end
            else
                args = {};
            end
            codegen(filename,'-args',args,'-config:lib','-lang:c++');
            if ~quiet && to_save.file_pct_act>0
                disp(['Finished C++ code generation of ' to_save.mat_name '.']);
            end
        end
    end
    
end

function out = save_mat_check(mat,mat_name,save_fct,save_split,path,filename_prefix,vars,fileopt_act,filec_act,file_pct_act)
    % This saves a matrix to file(s)
    out = [];
    if contains(save_split,[mat_name ' '])
        out.mat = mat;
        out.mat_name = mat_name;
        out.split = true;
        out.path = path;
        out.filename_prefix = filename_prefix;
        out.vars = vars;
        out.fileopt_act = fileopt_act;
        out.filec_act = filec_act;
        out.file_pct_act = file_pct_act;
    elseif contains(save_fct,[mat_name ' '])
        out.mat = mat;
        out.mat_name = mat_name;
        out.split = false;
        out.path = path;
        out.filename_prefix = filename_prefix;
        out.vars = vars;
        out.fileopt_act = fileopt_act;
        out.filec_act = filec_act;
        out.file_pct_act = file_pct_act;
    end
end

function repair_input(filename,vars)
    % read text of file, without deleting it
    filetext = fileread(filename);
    % replace inX with the vars name
    for idx=1:size(vars,2)
        if ~isscalar(vars{2,idx})
            filetext = replace(filetext, ['in' int2str(idx)], vars{1,idx});
            filetext = replace(filetext, ['IN' int2str(idx)], vars{1,idx});
        end
    end

    %write to file
    fileID = fopen(filename,'w'); %CONTENT DELETED!!
    fprintf(fileID, '%s',filetext); 
    fclose(fileID);
end





